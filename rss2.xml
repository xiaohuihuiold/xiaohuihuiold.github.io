<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>灰灰のBLOG</title>
    <link>https://blog.xhhold.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>记录一些东西</description>
    <pubDate>Tue, 08 Oct 2019 08:12:09 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>LeetCode记录--206.反转链表</title>
      <link>https://blog.xhhold.com/2019/10/08/LeetCode%E8%AE%B0%E5%BD%95-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <guid>https://blog.xhhold.com/2019/10/08/LeetCode%E8%AE%B0%E5%BD%95-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <pubDate>Tue, 08 Oct 2019 03:52:13 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="noopener">206. 反转链表</a><br>反转一个单链表。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li>输入:  </li></ul><blockquote><p>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</p></blockquote><ul><li>输出:  </li></ul><blockquote><p>5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><ul><li>进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="迭代方式"><a href="#迭代方式" class="headerlink" title="迭代方式"></a>迭代方式</h3><p>&emsp;&emsp;迭代的方式相对简单,就是循环把第一个Node放到第二个Node后面,然后把第二个Node放到第三个Node后面,以此类推.</p><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><svg width="500" height="150" viewbox="0 0 500 150">  <g id="node-rects">    <rect x="2" y="60" rx="8" ry="8" width="60" height="30" fill-opacity="0" stroke-width="2" stroke="#757575"/>    <rect x="102" y="60" rx="8" ry="8" width="60" height="30" fill-opacity="0" stroke-width="2" stroke="#757575"/>    <rect x="202" y="60" rx="8" ry="8" width="60" height="30" fill-opacity="0" stroke-width="2" stroke="#757575"/>    <rect x="302" y="60" rx="8" ry="8" width="60" height="30" fill-opacity="0" stroke-width="2" stroke="#757575"/>    <rect x="402" y="60" rx="8" ry="8" width="60" height="30" fill-opacity="0" stroke-width="2" stroke="#757575"/>  </g>  <g id="node-lines">    <line x1="54" y1="46" x2="110" y2="46" stroke="#757575" stroke-width="2"/>    <line x1="62" y1="74" x2="102" y2="74" stroke="#757575" stroke-width="2"/>    <line x1="162" y1="74" x2="202" y2="74" stroke="#757575" stroke-width="2"/>    <line x1="262" y1="74" x2="302" y2="74" stroke="#757575" stroke-width="2"/>    <line x1="362" y1="74" x2="402" y2="74" stroke="#757575" stroke-width="2"/>  </g>  <g id="node-texts">    <text x="10" y="51" font-size="20" fill="#E53935">head</text>    <text x="110" y="51" font-size="20" fill="#1E88E5">next</text>    <text x="26" y="81" font-size="20" fill="black">1</text>    <text x="126" y="81" font-size="20" fill="black">2</text>    <text x="226" y="81" font-size="20" fill="black">3</text>    <text x="326" y="81" font-size="20" fill="black">4</text>    <text x="426" y="81" font-size="20" fill="black">5</text>  </g></svg><ul><li><p>首先假设头部Node之前还有个叫prev的Node(NULL),要先把它们两个交换位置.</p></li><li><p>直接将head的next设置成prev就可以交换位置了.这里就是主要的交换的代码,后面的就是移动链表到下一个</p></li><li><p>这个时候,链表需要向头部移动,也就是将head设置成head的next,不过在这之前还得将head保存到prev里面</p></li><li><p>判断head是否为空,如果不为空则跳到第一步重复上面的操作<br><code>注:由于head为空时跳出循环,所以直接返回head是不行的,需要返回prev,最后一次循环时,它已经是链表头部了</code></p></li></ul><h3 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h3><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><h3 id="迭代方式-1"><a href="#迭代方式-1" class="headerlink" title="迭代方式"></a>迭代方式</h3><ul><li>C语言</li></ul><blockquote><p>执行用时: <code>8 ms</code>, 在所有 C 提交中击败了<code>59.94%</code>的用户<br>内存消耗: <code>7.7 MB</code>, 在所有 C 提交中击败了<code>5.08%</code>的用户</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        head-&gt;next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归方式-1"><a href="#递归方式-1" class="headerlink" title="递归方式"></a>递归方式</h3><ul><li>C语言</li></ul><blockquote><p>执行用时: <code>8 ms</code>, 在所有 C 提交中击败了<code>59.94%</code>的用户<br>内存消耗: <code>7.7 MB</code>, 在所有 C 提交中击败了<code>5.08%</code>的用户</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">reverseList</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newHead</span> = <span class="title">reverseList</span>(<span class="title">next</span>);</span></span><br><span class="line">  next-&gt;next = head;</span><br><span class="line">  head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://blog.xhhold.com/2019/10/08/LeetCode%E8%AE%B0%E5%BD%95-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>FlutterDesktop(二)--快捷键操作</title>
      <link>https://blog.xhhold.com/2019/08/23/FlutterDesktop-%E4%BA%8C-%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%93%8D%E4%BD%9C/</link>
      <guid>https://blog.xhhold.com/2019/08/23/FlutterDesktop-%E4%BA%8C-%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Fri, 23 Aug 2019 13:44:50 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&amp;emsp;&amp;emsp;FlutterDesktop因为要在多个平台上运行,所以如果想自己实现快捷键操作的话还是有点麻烦的.最近写了个方便进行快捷键操作的库&lt;code&gt;shortcut_keys&lt;/code&gt;,能够在多个平台方便的使用快捷键&lt;/p&gt;
&lt;h1 id=&quot;引入库&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;FlutterDesktop因为要在多个平台上运行,所以如果想自己实现快捷键操作的话还是有点麻烦的.最近写了个方便进行快捷键操作的库<code>shortcut_keys</code>,能够在多个平台方便的使用快捷键</p><h1 id="引入库"><a href="#引入库" class="headerlink" title="引入库"></a>引入库</h1><ul><li>由于库没有发布到pub上,所以库的引入可以使用<code>git</code>的方式引入,经常使用这个方式的话还得记得常清理缓存,不然可能库更新的却不刷新</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  shortcut_keys:</span></span><br><span class="line"><span class="attr">    git:</span> <span class="attr">https://github.com/xiaohuihuiold/shortcut_keys</span></span><br></pre></td></tr></table></figure><ul><li>然后在页面里面导入库文件<code>shortcut_keys.dart</code></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:shortcut_keys/shortcut_keys.dart'</span>;</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>把要使用快捷键的区域用<code>ShortcutKeysListener</code>包裹起来,<code>needFocus</code>参数是指是否需要<code>FocusNode</code>来获取焦点,如果不需要的话,则默认在当前页面都能触发快捷键.<code>shortcutData</code>参数里面就是一个快捷键列表,可以包含普通的快捷键以及带鼠标的快捷键</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ShortcutKeysListener(</span><br><span class="line">  needFocus: <span class="keyword">false</span>,</span><br><span class="line">  child: ... ,</span><br><span class="line">  shortcutData: [...] ,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><ul><li>添加普通的快捷键以及事件,比如复制<code>ctrl c</code>,运行后鼠标在页面上,然后按下复制的快捷键应该就会看到打印了一条<code>复制</code>消息</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shortcutData: [</span><br><span class="line">  ShortcutData(</span><br><span class="line">    shortcuts: [</span><br><span class="line">      ShortcutKeys.CTRL_LEFT,</span><br><span class="line">      ShortcutKeys.C,</span><br><span class="line">    ],</span><br><span class="line">    trigger: () &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'复制'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  ),</span><br><span class="line">],</span><br></pre></td></tr></table></figure><ul><li>添加带鼠标的快捷键,因为鼠标操作还有坐标等数据,所以<code>trigger</code>里面的加上一个参数来接收详细数据.这里以按下<code>ctrl</code>同时鼠标在当前区域时会触发输出当前鼠标坐标的快捷键为例子,<code>event</code>就是鼠标事件的详细信息.</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shortcutData: [</span><br><span class="line">  ShortcutData(</span><br><span class="line">    shortcuts: [</span><br><span class="line">      ShortcutKeys.CTRL_LEFT,</span><br><span class="line">      ShortcutKeys.MOUSE_REGION,</span><br><span class="line">    ],</span><br><span class="line">    trigger: (event) &#123;</span><br><span class="line">      PointerHoverEvent point = event;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;point.position.dx&#125;</span>,<span class="subst">$&#123;point.position.dy&#125;</span>'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  ),</span><br><span class="line">],</span><br></pre></td></tr></table></figure><ul><li>鼠标事件并不能多个一起使用.除了上面的在区域内触发,还有滚轮滚动<code>MOUSE_SCROLL</code>,左键单击<code>MOUSE_LEFT</code>等</li></ul><h1 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h1><p><a href="https://github.com/xiaohuihuiold/shortcut_keys" target="_blank" rel="noopener">https://github.com/xiaohuihuiold/shortcut_keys</a></p>]]></content:encoded>
      
      <comments>https://blog.xhhold.com/2019/08/23/FlutterDesktop-%E4%BA%8C-%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Flutter效果(三)--滚动歌词</title>
      <link>https://blog.xhhold.com/2019/08/23/Flutter%E6%95%88%E6%9E%9C-%E4%B8%89-%E6%BB%9A%E5%8A%A8%E6%AD%8C%E8%AF%8D/</link>
      <guid>https://blog.xhhold.com/2019/08/23/Flutter%E6%95%88%E6%9E%9C-%E4%B8%89-%E6%BB%9A%E5%8A%A8%E6%AD%8C%E8%AF%8D/</guid>
      <pubDate>Fri, 23 Aug 2019 13:41:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/2019/08/23/Flutter效果-三-滚动歌词/screenshot01.png&quot; alt=&quot;screenshot01&quot;&gt;&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="/2019/08/23/Flutter效果-三-滚动歌词/screenshot01.png" alt="screenshot01"></p>]]></content:encoded>
      
      <comments>https://blog.xhhold.com/2019/08/23/Flutter%E6%95%88%E6%9E%9C-%E4%B8%89-%E6%BB%9A%E5%8A%A8%E6%AD%8C%E8%AF%8D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>FlutterDesktop(一)--创建桌面程序</title>
      <link>https://blog.xhhold.com/2019/08/21/FlutterDesktop-%E4%B8%80-%E5%88%9B%E5%BB%BA%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F/</link>
      <guid>https://blog.xhhold.com/2019/08/21/FlutterDesktop-%E4%B8%80-%E5%88%9B%E5%BB%BA%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F/</guid>
      <pubDate>Wed, 21 Aug 2019 15:26:28 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;更新Flutter到最新版&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li>更新Flutter到最新版</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter upgrade</span><br></pre></td></tr></table></figure><ul><li><p>添加环境变量以启用Desktop支持</p><ul><li>变量名<code>ENABLE_FLUTTER_DESKTOP</code></li><li>变量值为<code>true</code></li><li>添加完成后<code>Linux</code>下可以使用<code>echo $ENABLE_FLUTTER_DESKTOP</code>查看是否添加成功,如果没有的话可以重启或者是使用<code>source</code>命令</li><li>如图<br><img src="/2019/08/21/FlutterDesktop-一-创建桌面程序/screenshot01.png" alt="screenshot01"></li></ul></li><li><p>添加好之后最好再执行一次<code>flutter doctor</code>,出现如下图所示就说明启用成功了,并且执行<code>flutter devices</code>也会显示当前pc,由于我使用的Linux,所以显示的也是Linux<br><img src="/2019/08/21/FlutterDesktop-一-创建桌面程序/screenshot02.png" alt="screenshot02"></p></li><li><p>准备工作到这里也就完成了,接下来该创建一个项目来试试看了</p></li></ul><h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><ul><li>和创建普通的Flutter项目一样</li></ul><p><img src="/2019/08/21/FlutterDesktop-一-创建桌面程序/screenshot03.png" alt="screenshot03"></p><ul><li>启用Desktop支持后,在选择设备下拉框里面就会出现当前系统的名称</li></ul><p><img src="/2019/08/21/FlutterDesktop-一-创建桌面程序/screenshot04.png" alt="screenshot04"></p><ul><li>如果这时候点击运行,就会出错,因为还没有配置相关文件</li></ul><p><img src="/2019/08/21/FlutterDesktop-一-创建桌面程序/screenshot05.png" alt="screenshot05"></p><ul><li>由于一些问题,所以在配置文件之前还需要修改一下dart代码,在<code>main.dart</code>里面加上下面这段,并且在<code>runApp(MyApp())</code>之前调用</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _setTargetPlatformForDesktop() &#123;</span><br><span class="line">  TargetPlatform targetPlatform;</span><br><span class="line">  <span class="keyword">if</span> (Platform.isMacOS) &#123;</span><br><span class="line">    targetPlatform = TargetPlatform.iOS;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Platform.isLinux || Platform.isWindows) &#123;</span><br><span class="line">    targetPlatform = TargetPlatform.android;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (targetPlatform != <span class="keyword">null</span>) &#123;</span><br><span class="line">    debugDefaultTargetPlatformOverride = targetPlatform;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h1><p>&emsp;&emsp;这里只针对<code>Linux</code>平台介绍,<code>windows</code>和<code>macos</code>也差不多,只是分别需要装<code>visual studio</code>和<code>xcode</code>,剩下的直接复制粘贴<a href="https://github.com/google/flutter-desktop-embedding/" target="_blank" rel="noopener">flutter-desktop-embedding</a>里面的例子就行了</p><ul><li>先clone<code>flutter-desktop-embedding</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/google/flutter-desktop-embedding/</span><br></pre></td></tr></table></figure><ul><li><p>再把里面<code>example</code>的linux部分的文件完全复制到创建的项目的linux文件夹里面,如果没有则可以自行创建</p></li><li><p>这时再点击运行,就会出现运行成功的窗口了</p></li></ul><p><img src="/2019/08/21/FlutterDesktop-一-创建桌面程序/screenshot06.png" alt="screenshot06"></p><ul><li>目前是运行了一个桌面程序的Demo,更加详细的内容会在后面介绍</li></ul>]]></content:encoded>
      
      <comments>https://blog.xhhold.com/2019/08/21/FlutterDesktop-%E4%B8%80-%E5%88%9B%E5%BB%BA%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Flutter文字渐变(二)--Text闪烁效果</title>
      <link>https://blog.xhhold.com/2019/08/04/Flutter%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98-%E4%BA%8C-Text%E9%97%AA%E7%83%81%E6%95%88%E6%9E%9C/</link>
      <guid>https://blog.xhhold.com/2019/08/04/Flutter%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98-%E4%BA%8C-Text%E9%97%AA%E7%83%81%E6%95%88%E6%9E%9C/</guid>
      <pubDate>Sun, 04 Aug 2019 12:55:14 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/08/04/Flutter文字渐变-二-Text闪烁效果/screenshot01.gif&quot; alt
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="/2019/08/04/Flutter文字渐变-二-Text闪烁效果/screenshot01.gif" alt="screenshot01"></p><p> <strong><a href="https://github.com/xiaohuihuiold/flutter_demos/tree/master/flutter_text_shimmer" target="_blank" rel="noopener">代码Github地址</a></strong></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;把上一篇教程<code>Flutter文字渐变(一)--Text渐变</code>的代码加个动画就可以做到shimmer闪烁效果.原理就是利用<code>Gradient</code>的<code>stops</code>属性改变了渐变色的分割比例来做到的.</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>首先把<code>Gradient</code>的<code>colors</code>改为三个颜色,中间的<code>Colors.white</code>就是闪烁的颜色,两边是文字原本的颜色,这些都可以自行选择合适的颜色</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colors: [Colors.grey, Colors.white, Colors.grey],</span><br></pre></td></tr></table></figure><ul><li>加上<code>stops</code>属性,<code>stops</code>的长度要和<code>colors</code>的长度一样.<code>value</code>是渐变位移的值,<code>stop</code>的值是从0.0~1.0,所以动画也设置0.0~1.0,中间0.4部分就是留给中间白色的区域</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stops: [value<span class="number">-0.2</span>,value,value+<span class="number">0.2</span>],</span><br></pre></td></tr></table></figure><ul><li>再接着创建动画控制器,动画播放时间设置的<code>1000ms</code>,注意需要给当前<code>State</code>混入<code>SingleTickerProviderStateMixin</code>,因为动画控制器的<code>vsync</code>参数需要一个<code>TickerProvider</code>类型的参数</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_controller = AnimationController(duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">1000</span>), vsync: <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><ul><li>动画控制器创建好了之后就该创建真正的动画了,这里用的是<code>Tween</code>补间动画.因为这里效果比较简单,所以用不上曲线动画之类的.调用<code>.animate</code>就能获得一个动画对象了,同时也绑定好了动画控制器,可以直接用控制器来控制动画的播放停止操作了.</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_animation = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0.0</span>, end: <span class="number">1.0</span>).animate(_controller);</span><br></pre></td></tr></table></figure><ul><li>使用动画控制器循环播放动画,只需要调用<code>.repeat</code>方法就行了.注意上面两条和这条代码是写在<code>State</code>的<code>initState</code>方法里面,也可以根据需要写在其它比如点击事件里面.</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_controller.repeat();</span><br></pre></td></tr></table></figure><ul><li><p>把动画作用到widget上面可以用<code>AnimatedBuilder</code>,<code>AnimatedBuilder</code>有两个必填的参数<code>animation</code>和<code>builder</code>.<code>animation</code>指的就是动画了,而<code>builder</code>就是当动画啊更新时会调用进行构建widget的.</p></li><li><p>通常只需要在<code>builder</code>里面取得<code>animation</code>的<code>value</code>,然后进行处理返回一个widget就行了</p></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AnimatedBuilder(</span><br><span class="line">  animation: _animation,</span><br><span class="line">  builder: (context, child) &#123;</span><br><span class="line">    <span class="built_in">double</span> value = _animation.value;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><ul><li><code>initState</code>完整代码</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_controller = AnimationController(duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">1000</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line">_animation = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0.0</span>, end: <span class="number">1.0</span>).animate(_controller);</span><br><span class="line">_controller.repeat();</span><br></pre></td></tr></table></figure><ul><li><code>build</code>完整代码</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Size size = MediaQuery.of(context).size;</span><br><span class="line"><span class="keyword">return</span> Scaffold(</span><br><span class="line">  backgroundColor: Colors.black,</span><br><span class="line">  body: Center(</span><br><span class="line">    child: AnimatedBuilder(</span><br><span class="line">      animation: _animation,</span><br><span class="line">      builder: (context, child) &#123;</span><br><span class="line">        <span class="built_in">double</span> value = _animation.value;</span><br><span class="line">        Gradient gradient = LinearGradient(</span><br><span class="line">          colors: [Colors.grey, Colors.white, Colors.grey],</span><br><span class="line">          stops: [value - <span class="number">0.2</span>, value, value + <span class="number">0.2</span>],</span><br><span class="line">        );</span><br><span class="line">        Shader shader = gradient.createShader(Rect.fromLTWH(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height));</span><br><span class="line">        <span class="keyword">return</span> Text(</span><br><span class="line">          <span class="string">'文字闪烁效果'</span>,</span><br><span class="line">          style: TextStyle(</span><br><span class="line">            fontSize: <span class="number">28.0</span>,</span><br><span class="line">            foreground: Paint()..shader = shader,</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://blog.xhhold.com/2019/08/04/Flutter%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98-%E4%BA%8C-Text%E9%97%AA%E7%83%81%E6%95%88%E6%9E%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Flutter文字渐变(一)--Text渐变</title>
      <link>https://blog.xhhold.com/2019/08/03/Flutter%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98-%E4%B8%80-Text%E6%B8%90%E5%8F%98/</link>
      <guid>https://blog.xhhold.com/2019/08/03/Flutter%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98-%E4%B8%80-Text%E6%B8%90%E5%8F%98/</guid>
      <pubDate>Sat, 03 Aug 2019 06:00:29 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/08/03/Flutter文字渐变-一-Text渐变/screenshot01.png&quot; alt=&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="/2019/08/03/Flutter文字渐变-一-Text渐变/screenshot01.png" alt="screenshot01"></p><p> <strong><a href="https://github.com/xiaohuihuiold/flutter_demos/tree/master/flutter_text_gradient" target="_blank" rel="noopener">代码Github地址</a></strong></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;原理其实很简单,就是利用<code>Gradient</code>创建<code>Shader</code>,再设置<code>Paint</code>的shader属性,最后传递到<code>TextStyle</code>的<code>foreground</code>参数.控制好渐变的参数就可以实现比如Shimmer效果或者是歌词效果(后面的文章会说到).</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>获取屏幕大小,这里只是用来设置渐变的范围用.所以也可以不获取然后自己填写.</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size size = MediaQuery.of(context).size;</span><br></pre></td></tr></table></figure><ul><li>创建一个渐变效果,这里是用的线性渐变,也可以替换成<code>RadialGradient</code>或者<code>SweepGradient</code>.颜色我使用的是蓝色和绿色的强调色<code>blueAccent</code>和<code>greenAccent</code>.<br>(<strong>注</strong>:<code>colors</code>数组的长度要$\geq2$,只有一个颜色值也没啥意义并且会报错)</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Gradient gradient = LinearGradient(colors: [</span><br><span class="line">  Colors.blueAccent,</span><br><span class="line">  Colors.greenAccent,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><ul><li>根据<code>gradient</code>创建<code>shader</code>,使用的<code>createShader</code>方法.<code>createShader</code>方法其实有两个参数,其中<code>rect</code>是必须要传递的,因为它指定了范围,而第二个参数<code>textDirection</code>是关于文字方向的,可以自己尝试一下,这里暂时用不到所以就只需要第一个,之后我可能会进行补充.</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shader shader = gradient.createShader(</span><br><span class="line">  Rect.fromLTWH(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>最后给目标文本设置文本样式<code>TextStyle</code>,样式里面的前景<code>foreground</code>使用指定刚才创建的<code>shader</code>的<code>Paint</code>就行了.<br>(<strong>注</strong>:前景是<code>foreground</code>,不要设置成背景<code>background</code>了,设置成背景就不是文字会有效果了,而是<code>Text</code>占的区域背景色会有渐变效果)</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  <span class="string">'文字渐变效果'</span>,</span><br><span class="line">  style: TextStyle(</span><br><span class="line">    fontSize: <span class="number">28.0</span>,</span><br><span class="line">    foreground: Paint()..shader = shader,</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>最后运行就可以看到效果.如果<code>gradient</code>,<code>shader</code>,<code>paint</code>没有必要动态创建或者不需要改变的话就不用放<code>build</code>里面每次都创建</li></ul><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取屏幕大小,创建shader指定rect范围时需要</span></span><br><span class="line">Size size = MediaQuery.of(context).size;</span><br><span class="line"><span class="comment">// 创建线性渐变,蓝色强调色到绿色强调色的渐变</span></span><br><span class="line"><span class="comment">// 这里的渐变效果是从左往右的线性渐变</span></span><br><span class="line">Gradient gradient = LinearGradient(colors: [</span><br><span class="line">  Colors.blueAccent,</span><br><span class="line">  Colors.greenAccent,</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 根据渐变创建shader</span></span><br><span class="line"><span class="comment">// 范围是从左上角(0,0),到右下角(size.width,size.height)全屏幕范围</span></span><br><span class="line">Shader shader = gradient.createShader(</span><br><span class="line">  Rect.fromLTWH(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Scaffold(</span><br><span class="line">  body: Center(</span><br><span class="line">    child: Text(</span><br><span class="line">      <span class="string">'文字渐变效果'</span>,</span><br><span class="line">      style: TextStyle(</span><br><span class="line">        fontSize: <span class="number">28.0</span>,</span><br><span class="line">        <span class="comment">// 创建一个新的Paint并指定shader</span></span><br><span class="line">        <span class="comment">// 注意这里能复用的话还是不要动态创建了</span></span><br><span class="line">        foreground: Paint()..shader = shader,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://blog.xhhold.com/2019/08/03/Flutter%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98-%E4%B8%80-Text%E6%B8%90%E5%8F%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>计算机图形学(一)--DDA画线算法</title>
      <link>https://blog.xhhold.com/2019/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E4%B8%80-DDA%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/</link>
      <guid>https://blog.xhhold.com/2019/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E4%B8%80-DDA%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/</guid>
      <pubDate>Sun, 31 Mar 2019 07:19:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;DDA直线绘制算法&quot;&gt;&lt;a href=&quot;#DDA直线绘制算法&quot; class=&quot;headerlink&quot; title=&quot;DDA直线绘制算法&quot;&gt;&lt;/a&gt;DDA直线绘制算法&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;DDA就是&lt;code&gt;数值微分&lt;/code&gt;Digital 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="DDA直线绘制算法"><a href="#DDA直线绘制算法" class="headerlink" title="DDA直线绘制算法"></a>DDA直线绘制算法</h1><p>&emsp;&emsp;DDA就是<code>数值微分</code>Digital Differential Analyzer)的简称。在一个坐标轴上以单位间隔对线段进行取样，从而确定另一个最靠近路径对应的整数值。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>&emsp;&emsp;利用<code>增量思想</code>使得在确定直线中每个点的坐标时只进行一次加法运算</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>&emsp;&emsp;由于直线的<code>斜率</code>($k={{y1-y0}\over{x1-x0}}$)有可能是小数，并且在计算出坐标后的值还得进行取整，所以此算法不利于硬件实现</p><h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><h2 id="直线方程斜截式"><a href="#直线方程斜截式" class="headerlink" title="直线方程斜截式"></a>直线方程斜截式</h2><p>&emsp;&emsp;($y=kx+b$)，其中<code>k</code>是<code>斜率</code>，<code>b</code>是直线在<code>y</code>轴上的<code>截距</code>，而<code>斜率</code>($k={\Delta y \over \Delta x}={{y1-y0}\over{x1-x0}}$)</p><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p>&emsp;&emsp;现在需要画一条经过点$P_0(2,3)$和点$P_1(17,12)$的直线<br>&emsp;&emsp;根据直线方程斜截式($y=kx+b$)，此时<code>b=0</code>，其中<code>斜率</code>($k={{y1-y0}\over{x1-x0}}={{12-3}\over{17-2}}=0.6$)，可以表示为：$y=0.6x$</p><h2 id="用图表示"><a href="#用图表示" class="headerlink" title="用图表示"></a>用图表示</h2><p>&emsp;&emsp;* 第<code>0</code>个点(2,3)</p><svg width="400" height="300" viewbox="0 0 200 150">  <g id="grid">    <path d="    M10 0 L10 150    M20 10 L20 140    M30 10 L30 140    M40 10 L40 140    M50 10 L50 140    M60 10 L60 140    M70 10 L70 140    M80 10 L80 140    M90 10 L90 140    M100 10 L100 140    M110 10 L110 140    M120 10 L120 140    M130 10 L130 140    M140 10 L140 140    M150 10 L150 140    M160 10 L160 140    M170 10 L170 140    M180 10 L180 140    M190 10 L190 140    M0 140 L200 140    M10 130 L190 130    M10 120 L190 120    M10 110 L190 110    M10 100 L190 100    M10 90 L190 90    M10 80 L190 80    M10 70 L190 70    M10 60 L190 60    M10 50 L190 50    M10 40 L190 40    M10 30 L190 30    M10 20 L190 20    M10 10 L190 10    " stroke="black" stroke-width="1"/>  </g>  <g id="coords">    <text x="0" y="150" font-size="8" fill="black">0</text>    <text x="13" y="150" font-size="8" fill="grey">1</text>    <text x="23" y="150" font-size="8" fill="black">2</text>    <text x="33" y="150" font-size="8" fill="grey">3</text>    <text x="43" y="150" font-size="8" fill="black">4</text>    <text x="53" y="150" font-size="8" fill="grey">5</text>    <text x="63" y="150" font-size="8" fill="black">6</text>    <text x="73" y="150" font-size="8" fill="grey">7</text>    <text x="83" y="150" font-size="8" fill="black">8</text>    <text x="93" y="150" font-size="8" fill="grey">9</text>    <text x="100" y="150" font-size="8" fill="black">10</text>    <text x="110" y="150" font-size="8" fill="grey">11</text>    <text x="120" y="150" font-size="8" fill="black">12</text>    <text x="130" y="150" font-size="8" fill="grey">13</text>    <text x="140" y="150" font-size="8" fill="black">14</text>    <text x="150" y="150" font-size="8" fill="grey">15</text>    <text x="160" y="150" font-size="8" fill="black">16</text>    <text x="170" y="150" font-size="8" fill="grey">17</text>    <text x="180" y="150" font-size="8" fill="black">18</text>    <text x="0" y="138" font-size="8" fill="grey">1</text>    <text x="0" y="128" font-size="8" fill="black">2</text>    <text x="0" y="118" font-size="8" fill="grey">3</text>    <text x="0" y="108" font-size="8" fill="black">4</text>    <text x="0" y="98" font-size="8" fill="grey">5</text>    <text x="0" y="88" font-size="8" fill="black">6</text>    <text x="0" y="78" font-size="8" fill="grey">7</text>    <text x="0" y="68" font-size="8" fill="black">8</text>    <text x="0" y="58" font-size="8" fill="grey">9</text>    <text x="0" y="48" font-size="8" fill="black">10</text>    <text x="0" y="38" font-size="8" fill="grey">11</text>    <text x="0" y="28" font-size="8" fill="black">12</text>    <text x="0" y="18" font-size="8" fill="grey">13</text>  </g>  <g id="points">    <rect x="20" y="110" width="10" height="10" fill="red"/>  </g></svg><p>&emsp;&emsp;* 第<code>1</code>个点<code>y=0.6x1=0.6</code>，坐标<code>x</code>上加<code>1</code>、<code>y</code>加上<code>0.6</code>，取整后<code>(3,4)</code></p><svg width="400" height="300" viewbox="0 0 200 150">  <g id="grid">    <path d="    M10 0 L10 150    M20 10 L20 140    M30 10 L30 140    M40 10 L40 140    M50 10 L50 140    M60 10 L60 140    M70 10 L70 140    M80 10 L80 140    M90 10 L90 140    M100 10 L100 140    M110 10 L110 140    M120 10 L120 140    M130 10 L130 140    M140 10 L140 140    M150 10 L150 140    M160 10 L160 140    M170 10 L170 140    M180 10 L180 140    M190 10 L190 140    M0 140 L200 140    M10 130 L190 130    M10 120 L190 120    M10 110 L190 110    M10 100 L190 100    M10 90 L190 90    M10 80 L190 80    M10 70 L190 70    M10 60 L190 60    M10 50 L190 50    M10 40 L190 40    M10 30 L190 30    M10 20 L190 20    M10 10 L190 10    " stroke="black" stroke-width="1"/>  </g>  <g id="coords">    <text x="0" y="150" font-size="8" fill="black">0</text>    <text x="13" y="150" font-size="8" fill="grey">1</text>    <text x="23" y="150" font-size="8" fill="black">2</text>    <text x="33" y="150" font-size="8" fill="grey">3</text>    <text x="43" y="150" font-size="8" fill="black">4</text>    <text x="53" y="150" font-size="8" fill="grey">5</text>    <text x="63" y="150" font-size="8" fill="black">6</text>    <text x="73" y="150" font-size="8" fill="grey">7</text>    <text x="83" y="150" font-size="8" fill="black">8</text>    <text x="93" y="150" font-size="8" fill="grey">9</text>    <text x="100" y="150" font-size="8" fill="black">10</text>    <text x="110" y="150" font-size="8" fill="grey">11</text>    <text x="120" y="150" font-size="8" fill="black">12</text>    <text x="130" y="150" font-size="8" fill="grey">13</text>    <text x="140" y="150" font-size="8" fill="black">14</text>    <text x="150" y="150" font-size="8" fill="grey">15</text>    <text x="160" y="150" font-size="8" fill="black">16</text>    <text x="170" y="150" font-size="8" fill="grey">17</text>    <text x="180" y="150" font-size="8" fill="black">18</text>    <text x="0" y="138" font-size="8" fill="grey">1</text>    <text x="0" y="128" font-size="8" fill="black">2</text>    <text x="0" y="118" font-size="8" fill="grey">3</text>    <text x="0" y="108" font-size="8" fill="black">4</text>    <text x="0" y="98" font-size="8" fill="grey">5</text>    <text x="0" y="88" font-size="8" fill="black">6</text>    <text x="0" y="78" font-size="8" fill="grey">7</text>    <text x="0" y="68" font-size="8" fill="black">8</text>    <text x="0" y="58" font-size="8" fill="grey">9</text>    <text x="0" y="48" font-size="8" fill="black">10</text>    <text x="0" y="38" font-size="8" fill="grey">11</text>    <text x="0" y="28" font-size="8" fill="black">12</text>    <text x="0" y="18" font-size="8" fill="grey">13</text>  </g>  <g id="points">    <rect x="20" y="110" width="10" height="10" fill="green"/>    <rect x="30" y="100" width="10" height="10" fill="red"/>  </g></svg><p>&emsp;&emsp;* 第<code>2</code>个点<code>y=0.6x2=1.2</code>，坐标<code>x</code>上加<code>1</code>、<code>y</code>加上<code>1.2</code>，取整后<code>(4,4)</code></p><svg width="400" height="300" viewbox="0 0 200 150">  <g id="grid">    <path d="    M10 0 L10 150    M20 10 L20 140    M30 10 L30 140    M40 10 L40 140    M50 10 L50 140    M60 10 L60 140    M70 10 L70 140    M80 10 L80 140    M90 10 L90 140    M100 10 L100 140    M110 10 L110 140    M120 10 L120 140    M130 10 L130 140    M140 10 L140 140    M150 10 L150 140    M160 10 L160 140    M170 10 L170 140    M180 10 L180 140    M190 10 L190 140    M0 140 L200 140    M10 130 L190 130    M10 120 L190 120    M10 110 L190 110    M10 100 L190 100    M10 90 L190 90    M10 80 L190 80    M10 70 L190 70    M10 60 L190 60    M10 50 L190 50    M10 40 L190 40    M10 30 L190 30    M10 20 L190 20    M10 10 L190 10    " stroke="black" stroke-width="1"/>  </g>  <g id="coords">    <text x="0" y="150" font-size="8" fill="black">0</text>    <text x="13" y="150" font-size="8" fill="grey">1</text>    <text x="23" y="150" font-size="8" fill="black">2</text>    <text x="33" y="150" font-size="8" fill="grey">3</text>    <text x="43" y="150" font-size="8" fill="black">4</text>    <text x="53" y="150" font-size="8" fill="grey">5</text>    <text x="63" y="150" font-size="8" fill="black">6</text>    <text x="73" y="150" font-size="8" fill="grey">7</text>    <text x="83" y="150" font-size="8" fill="black">8</text>    <text x="93" y="150" font-size="8" fill="grey">9</text>    <text x="100" y="150" font-size="8" fill="black">10</text>    <text x="110" y="150" font-size="8" fill="grey">11</text>    <text x="120" y="150" font-size="8" fill="black">12</text>    <text x="130" y="150" font-size="8" fill="grey">13</text>    <text x="140" y="150" font-size="8" fill="black">14</text>    <text x="150" y="150" font-size="8" fill="grey">15</text>    <text x="160" y="150" font-size="8" fill="black">16</text>    <text x="170" y="150" font-size="8" fill="grey">17</text>    <text x="180" y="150" font-size="8" fill="black">18</text>    <text x="0" y="138" font-size="8" fill="grey">1</text>    <text x="0" y="128" font-size="8" fill="black">2</text>    <text x="0" y="118" font-size="8" fill="grey">3</text>    <text x="0" y="108" font-size="8" fill="black">4</text>    <text x="0" y="98" font-size="8" fill="grey">5</text>    <text x="0" y="88" font-size="8" fill="black">6</text>    <text x="0" y="78" font-size="8" fill="grey">7</text>    <text x="0" y="68" font-size="8" fill="black">8</text>    <text x="0" y="58" font-size="8" fill="grey">9</text>    <text x="0" y="48" font-size="8" fill="black">10</text>    <text x="0" y="38" font-size="8" fill="grey">11</text>    <text x="0" y="28" font-size="8" fill="black">12</text>    <text x="0" y="18" font-size="8" fill="grey">13</text>  </g>  <g id="points">    <rect x="20" y="110" width="10" height="10" fill="green"/>    <rect x="30" y="100" width="10" height="10" fill="green"/>    <rect x="40" y="100" width="10" height="10" fill="red"/>  </g></svg><p>……</p><p>&emsp;&emsp;* 一直到第<code>15</code>个点<code>y=0.6x15=9.0</code>，坐标<code>(17,12)</code></p><svg width="400" height="300" viewbox="0 0 200 150">  <g id="grid">    <path d="    M10 0 L10 150    M20 10 L20 140    M30 10 L30 140    M40 10 L40 140    M50 10 L50 140    M60 10 L60 140    M70 10 L70 140    M80 10 L80 140    M90 10 L90 140    M100 10 L100 140    M110 10 L110 140    M120 10 L120 140    M130 10 L130 140    M140 10 L140 140    M150 10 L150 140    M160 10 L160 140    M170 10 L170 140    M180 10 L180 140    M190 10 L190 140    M0 140 L200 140    M10 130 L190 130    M10 120 L190 120    M10 110 L190 110    M10 100 L190 100    M10 90 L190 90    M10 80 L190 80    M10 70 L190 70    M10 60 L190 60    M10 50 L190 50    M10 40 L190 40    M10 30 L190 30    M10 20 L190 20    M10 10 L190 10    " stroke="black" stroke-width="1"/>  </g>  <g id="coords">    <text x="0" y="150" font-size="8" fill="black">0</text>    <text x="13" y="150" font-size="8" fill="grey">1</text>    <text x="23" y="150" font-size="8" fill="black">2</text>    <text x="33" y="150" font-size="8" fill="grey">3</text>    <text x="43" y="150" font-size="8" fill="black">4</text>    <text x="53" y="150" font-size="8" fill="grey">5</text>    <text x="63" y="150" font-size="8" fill="black">6</text>    <text x="73" y="150" font-size="8" fill="grey">7</text>    <text x="83" y="150" font-size="8" fill="black">8</text>    <text x="93" y="150" font-size="8" fill="grey">9</text>    <text x="100" y="150" font-size="8" fill="black">10</text>    <text x="110" y="150" font-size="8" fill="grey">11</text>    <text x="120" y="150" font-size="8" fill="black">12</text>    <text x="130" y="150" font-size="8" fill="grey">13</text>    <text x="140" y="150" font-size="8" fill="black">14</text>    <text x="150" y="150" font-size="8" fill="grey">15</text>    <text x="160" y="150" font-size="8" fill="black">16</text>    <text x="170" y="150" font-size="8" fill="grey">17</text>    <text x="180" y="150" font-size="8" fill="black">18</text>    <text x="0" y="138" font-size="8" fill="grey">1</text>    <text x="0" y="128" font-size="8" fill="black">2</text>    <text x="0" y="118" font-size="8" fill="grey">3</text>    <text x="0" y="108" font-size="8" fill="black">4</text>    <text x="0" y="98" font-size="8" fill="grey">5</text>    <text x="0" y="88" font-size="8" fill="black">6</text>    <text x="0" y="78" font-size="8" fill="grey">7</text>    <text x="0" y="68" font-size="8" fill="black">8</text>    <text x="0" y="58" font-size="8" fill="grey">9</text>    <text x="0" y="48" font-size="8" fill="black">10</text>    <text x="0" y="38" font-size="8" fill="grey">11</text>    <text x="0" y="28" font-size="8" fill="black">12</text>    <text x="0" y="18" font-size="8" fill="grey">13</text>  </g>  <g id="points">    <rect x="20" y="110" width="10" height="10" fill="green"/>    <rect x="30" y="100" width="10" height="10" fill="green"/>    <rect x="40" y="100" width="10" height="10" fill="green"/>    <rect x="50" y="90" width="10" height="10" fill="green"/>    <rect x="60" y="90" width="10" height="10" fill="green"/>    <rect x="70" y="80" width="10" height="10" fill="green"/>    <rect x="80" y="70" width="10" height="10" fill="green"/>    <rect x="90" y="70" width="10" height="10" fill="green"/>    <rect x="100" y="60" width="10" height="10" fill="green"/>    <rect x="110" y="60" width="10" height="10" fill="green"/>    <rect x="120" y="50" width="10" height="10" fill="green"/>    <rect x="130" y="40" width="10" height="10" fill="green"/>    <rect x="140" y="40" width="10" height="10" fill="green"/>    <rect x="150" y="30" width="10" height="10" fill="green"/>    <rect x="160" y="30" width="10" height="10" fill="green"/>    <rect x="170" y="20" width="10" height="10" fill="red"/>  </g></svg><p>&emsp;&emsp;* 至此就完成了一条直线的绘制</p><h2 id="增量"><a href="#增量" class="headerlink" title="增量"></a>增量</h2><p>&emsp;&emsp;可以看到，上面的方法可以快速的画出一条直线，不过还需要优化一下。之前说的DDA每次确定一个点只需要一次加法运算，但是这里却进行了一次乘法加上一次加法。<br>&emsp;&emsp;可以看出来，这里的y就是每次<code>斜率</code>加上了上一次的y坐标：<br>$y<em>i=kx+b$<br>下一个点表示为<br>$y</em>{i+1}=k(x+1)+b$<br>$\qquad=kx+k+b$<br>$\qquad=kx+b+k$<br>可以看到这里的$kx+b$就等于$y<em>i$<br>所以<br>$y</em>{i+1}=y_i+k$</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><ul><li>先声明一个画线的函数：<br><strong>x0</strong>：起点<code>x</code>坐标<br><strong>y0</strong>：起点<code>y</code>坐标<br><strong>x1</strong>：结束点<code>x</code>坐标<br><strong>y1</strong>：结束点<code>y</code>坐标</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dda</span><span class="params">(<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1,<span class="keyword">int</span> y1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="当斜率-0-lt-k-leq1-时"><a href="#当斜率-0-lt-k-leq1-时" class="headerlink" title="当斜率$0&lt;|k|\leq1$时"></a>当斜率$0&lt;|k|\leq1$时</h2><p>&emsp;&emsp;斜率<code>小于等于1</code>时可以直接通过递增x方向来计算出y的值，但如果斜率大于1就会出现点不连续的情况。</p><ul><li>先计算两个坐标的<code>x</code>、<code>y</code>坐标差</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> dx=x1-x0;</span><br><span class="line"><span class="keyword">float</span> dy=y1-y1;</span><br><span class="line"><span class="keyword">float</span> y=y0;</span><br></pre></td></tr></table></figure><ul><li>然后根据($k={\Delta y \over \Delta x}$)求出<code>斜率</code>，<code>注：dx为0的情况未考虑进去</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> k=dy/dx;</span><br></pre></td></tr></table></figure><ul><li>之前就已经推导出<code>y</code>的值其实就是每次都用斜率加上前一次的值，所以求<code>y</code>的代码可以这样写</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y+=k;</span><br></pre></td></tr></table></figure><ul><li>再使用循环来绘制所有点，由于这里是<code>斜率</code>小于等于1的情况，所以判断<code>x0</code>是否小于等于结束点的<code>x1</code>作为循环条件</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;x0&lt;=x1;++x0)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再把求<code>y</code>值以及画点的代码添加进去</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;x0&lt;=x1;++x0)</span><br><span class="line">&#123;</span><br><span class="line">  drawPoint(x0,(<span class="keyword">int</span>)(y+<span class="number">0.5</span>));</span><br><span class="line">  y+=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>完整代码如下</strong> <code>注：未考虑dx为0的情况</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> dx=x1-x0;</span><br><span class="line"><span class="keyword">float</span> dy=y1-y1;</span><br><span class="line"><span class="keyword">float</span> y=y0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> k=dy/dx;</span><br><span class="line"><span class="keyword">for</span>(;x0&lt;=x1;++x0)</span><br><span class="line">&#123;</span><br><span class="line">  drawPoint(x0,(<span class="keyword">int</span>)(y+<span class="number">0.5</span>));</span><br><span class="line">  y+=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="当斜率-k-gt-1-时"><a href="#当斜率-k-gt-1-时" class="headerlink" title="当斜率$|k|&gt;1$时"></a>当斜率$|k|&gt;1$时</h2><p>&emsp;&emsp;斜率<code>大于1</code>时只需要把计算y值改成计算x值就行了，注意<code>k=dx/dy</code>，<code>注：dy可能为0</code></p><ul><li><strong>完整代码如下</strong> <code>注：未考虑dy为0的情况</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> dx=x1-x0;</span><br><span class="line"><span class="keyword">float</span> dy=y1-y1;</span><br><span class="line"><span class="keyword">float</span> x=x0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> k=dx/dy;</span><br><span class="line"><span class="keyword">for</span>(;y0&lt;=y1;++y0)</span><br><span class="line">&#123;</span><br><span class="line">  drawPoint((<span class="keyword">int</span>)(x+<span class="number">0.5</span>),y0);</span><br><span class="line">  x+=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适用于任何斜率的方法"><a href="#适用于任何斜率的方法" class="headerlink" title="适用于任何斜率的方法"></a>适用于任何斜率的方法</h2><p>&emsp;&emsp;由于上面两种都只针对特定的斜率以及特定的方向绘制直线，所以还得优化下</p><ul><li>首先还是得先计算两个坐标的<code>x</code>、<code>y</code>的差</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> dx=x1-x0;</span><br><span class="line"><span class="keyword">float</span> dy=y1-y1;</span><br></pre></td></tr></table></figure><ul><li>然后这里多了个<code>steps</code>变量，可以看作是绘制这条直线的点的数量。<code>注：这里引入了math.h头文件用来获取绝对值</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> steps=<span class="built_in">abs</span>(y1-y0);</span><br><span class="line"><span class="comment">// 这里是取绘制点数最多的值</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(dx)&gt;<span class="built_in">fabs</span>(dy))</span><br><span class="line">  steps=<span class="built_in">abs</span>(x1-x0);</span><br><span class="line"><span class="comment">// 注意：在这之后steps可能为0,</span></span><br><span class="line"><span class="comment">// steps为0的话就只需要画一个起点就行了(这里未写出)，不需要再执行下面的代码</span></span><br></pre></td></tr></table></figure><ul><li>因为现在是两种情况都要考虑，所以就一次性计算出每一步(step)的<code>x</code>与<code>y</code>的增量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先初始化两个坐标为起点</span></span><br><span class="line"><span class="keyword">float</span> x=x0;</span><br><span class="line"><span class="keyword">float</span> y=y0;</span><br><span class="line"><span class="comment">// 然后定义两个x和y的增量变量</span></span><br><span class="line"><span class="comment">// 分别用两点的x、y的差除与需要绘制的点数来获得每绘制结束一个点后需要前进多少</span></span><br><span class="line"><span class="keyword">float</span> xinc=dx/steps;</span><br><span class="line"><span class="keyword">float</span> yinc=dy/steps;</span><br></pre></td></tr></table></figure><ul><li>首先第一个点要自己绘制。<code>注：这里引入了math.h头文件进行四舍五入操作</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawPoint(round(x),round(y));</span><br></pre></td></tr></table></figure><ul><li>剩下的点，绘制<code>steps</code>个就行了</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;steps;++i)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>计算当前点的位置，直接<code>x</code>和<code>y</code>分别加上增量就行了</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x+=xinc;</span><br><span class="line">y+=yinc;</span><br></pre></td></tr></table></figure><ul><li>绘制点的方法不变，把这些放进循环里面</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;steps;++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 注意这里需要放到本次循环开始</span></span><br><span class="line">  <span class="comment">// 因为第一个点已经绘制了</span></span><br><span class="line">  x+=xinc;</span><br><span class="line">  y+=yinc;</span><br><span class="line"></span><br><span class="line">  drawPoint(round(x),round(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>完整代码如下</strong> <code>注：未考虑steps为0的情况</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> dx=x1-x0;</span><br><span class="line"><span class="keyword">float</span> dy=y1-y1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> steps=<span class="built_in">abs</span>(y1-y0);</span><br><span class="line"><span class="comment">// 这里是取绘制点数最多的值</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(dx)&gt;<span class="built_in">fabs</span>(dy))</span><br><span class="line">  steps=<span class="built_in">abs</span>(x1-x0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先初始化两个坐标为起点</span></span><br><span class="line"><span class="keyword">float</span> x=x0;</span><br><span class="line"><span class="keyword">float</span> y=y0;</span><br><span class="line"><span class="comment">// 然后定义两个x和y的增量变量</span></span><br><span class="line"><span class="comment">// 分别用两点的x、y的差除与需要绘制的点数来获得每绘制结束一个点后需要前进多少</span></span><br><span class="line"><span class="keyword">float</span> xinc=dx/steps;</span><br><span class="line"><span class="keyword">float</span> yinc=dy/steps;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制起点</span></span><br><span class="line">drawPoint(round(x),round(y));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;steps;++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 注意这里需要放到本次循环开始</span></span><br><span class="line">  <span class="comment">// 因为第一个点已经绘制了</span></span><br><span class="line">  x+=xinc;</span><br><span class="line">  y+=yinc;</span><br><span class="line"></span><br><span class="line">  drawPoint(round(x),round(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h1><p><a href="https://github.com/xiaohuihuiold/computer_graphics/blob/master/line/dda.c" target="_blank" rel="noopener">dda.c</a></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&emsp;&emsp;DDA的计算方法比直接套用直线方程的效率要高得多。虽然从一个乘法一个加法缩减到了一个加法，但是在进行计算中的浮点运算和取整依旧比较耗时。后面会接触绘制直线的其它算法。</p>]]></content:encoded>
      
      <comments>https://blog.xhhold.com/2019/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E4%B8%80-DDA%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java多线程(二)--volatile</title>
      <link>https://blog.xhhold.com/2019/03/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%8C-volatile/</link>
      <guid>https://blog.xhhold.com/2019/03/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%8C-volatile/</guid>
      <pubDate>Tue, 12 Mar 2019 15:19:43 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>https://blog.xhhold.com/2019/03/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%8C-volatile/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java多线程(一)--synchronized</title>
      <link>https://blog.xhhold.com/2019/03/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80-synchronized/</link>
      <guid>https://blog.xhhold.com/2019/03/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80-synchronized/</guid>
      <pubDate>Mon, 11 Mar 2019 02:10:04 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;synchronized&quot;&gt;&lt;a href=&quot;#synchronized&quot; class=&quot;headerlink&quot; title=&quot;synchronized&quot;&gt;&lt;/a&gt;synchronized&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;synchronized保证使用同一
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>&emsp;&emsp;synchronized保证使用同一个对象锁的代码块在同一时间只能被一个线程执行。<code>方法</code>、<code>对象</code>、<code>静态方法</code>、<code>class类锁</code>都属于对象锁（Class对象是唯一的、全局的）<br><code>方法</code>：<code>this</code>对象<br><code>对象</code>：创建的对象<br><code>静态方法</code>：方法所在类的<code>Class对象</code><br><code>class类锁</code>：<code>Class对象</code></p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><ul><li><p>代码块</p><p>&emsp;&emsp;如果只有一个obj对象，当线程1执行到synchronized代码块时，线程2想执行synchronized代码块的话要等obj的锁被释放，也就是线程1把synchronized代码块执行完成。因为这里使用的是同一个对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj=<span class="keyword">new</span> Object();</span><br><span class="line">  </span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  另一种写法是使用<code>this</code>，因为this指的是当前对象，所以和上面的意思一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法<br>直接加在普通方法上和<code>synchronized(this)</code>意思一样，直接使用当前对象加锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h2><ul><li><p>代码块<br>&emsp;&emsp;因为所有class都含有一个Class对]象，并且在程序运行时是唯一的，所以就相对于使用的是同一个对象进行加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Main.class)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法(<code>static</code>)<br>&emsp;&emsp;<code>synchronized</code>修饰普通方法加锁的是方法所在对象，而在静态方法里面使用加锁的是方法所在的类的class对象，所以效果等同于类锁的代码块形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomethong</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ul><li>不可中断<br>只能等待另一个线程释放锁之后才能获取锁</li><li>可重入性质<br>同一线程的外层获取锁之后，内层也可以再次获得锁，而不需要等待释放锁。避免了外层获取而内层不能获取，然后外层又因为内层阻塞释放不了锁而形成的死锁<br>锁的粒度是<code>线程</code></li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ul><li>可见性原理：解锁时把工作内存的共享变量值刷新到主内存，加锁时清空工作内存的共享变量值</li><li>加锁和释放锁使用<code>monitor</code>来实现</li><li>重入锁靠的加减<code>monitor</code><ul><li>当获得锁之后，<code>monitor</code>+1，当内部代码再次获取锁时，<code>monitor</code>再+1</li><li>内部代码执行完离开时，<code>monitor</code>-1，外层执行完成再次-1</li><li>当<code>monitor</code>等于0时说明锁已经被释放了,不等于0则其它尝试获取锁的线程会阻塞</li></ul></li><li><p>加锁使用<code>monitorenter</code>，释放使用<code>monitorexit</code><br>可以通过反编译代码看到</p><ul><li>先使用<code>javac</code>编译下面的代码</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>然后使用<code>javap -verbose 类名</code>获得汇编代码（这里截取部分反编译后的代码）<br>可以看到<code>3:</code>处加锁使用的<code>monitorenter</code>以及<code>5:</code>处使用的<code>monitorexit</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0: aload_0</span><br><span class="line">1: dup</span><br><span class="line">2: astore_1</span><br><span class="line">3: monitorenter</span><br><span class="line">4: aload_1</span><br><span class="line">5: monitorexit</span><br><span class="line">6: goto          14</span><br><span class="line">9: astore_2</span><br><span class="line">10: aload_1</span><br><span class="line">11: monitorexit</span><br><span class="line">12: aload_2</span><br><span class="line">13: athrow</span><br><span class="line">14: return</span><br></pre></td></tr></table></figure></li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>效率低<ul><li>锁的释放情况少</li><li>不可中断</li><li>获取锁不能设置超时</li></ul></li><li>不够灵活<ul><li>加锁和释放时机单一</li><li>每个锁只有单一的条件</li></ul></li><li>无法知道锁的获取状态</li></ul><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>锁对象不能为空，否则会报异常，因为加锁靠的是对象的<code>monitor</code></li><li>作用域不要太大，否则可能效率低</li><li>避免死锁</li><li>使用推荐：并发包 &gt; synchronized &gt; Lock</li></ul>]]></content:encoded>
      
      <comments>https://blog.xhhold.com/2019/03/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80-synchronized/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Learn OpenGL(一)--简介与创建窗口</title>
      <link>https://blog.xhhold.com/2019/02/21/Learn-OpenGL-%E4%B8%80-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3/</link>
      <guid>https://blog.xhhold.com/2019/02/21/Learn-OpenGL-%E4%B8%80-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3/</guid>
      <pubDate>Thu, 21 Feb 2019 14:57:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/2019/02/21/Learn-OpenGL-一-简介与创建窗口/opengl_logo.jpg&quot; alt=&quot;opengl_logo&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;a href=&quot;https://github.com/xiaohuihuiol
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="/2019/02/21/Learn-OpenGL-一-简介与创建窗口/opengl_logo.jpg" alt="opengl_logo"></p><p> <strong><a href="https://github.com/xiaohuihuiold/opengl" target="_blank" rel="noopener">代码Github地址</a></strong></p><h1 id="OpenGL-简介"><a href="#OpenGL-简介" class="headerlink" title="OpenGL 简介"></a>OpenGL 简介</h1><p>&emsp;&emsp;OpenGL是一个由<a href="https://www.khronos.org/" target="_blank" rel="noopener">Khronos Group</a>维护的图形绘制的规范<br>&emsp;&emsp;OpenGL规范规定了函数的执行、输出，但是具体的实现则是由库的开发者(通常指显卡生产商)来实现的，不同的库实现可能不一样<br>&emsp;&emsp;OpenGL本质上是一个大状态机，通过改变上下文(context)的变量告诉OpenGL怎么绘图</p><h1 id="创建窗口-GLFW"><a href="#创建窗口-GLFW" class="headerlink" title="创建窗口(GLFW)"></a>创建窗口(GLFW)</h1><p>创建窗口可以使用GLUT，SDL，QT，GLFW等，这里我用的是GLFW</p><h2 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h2><p>&emsp;&emsp;GLFW是个开源的支持多个平台的库，支持OpenGL、Vulkan。提供创建窗口、事件接收等。</p><h3 id="GLFW安装"><a href="#GLFW安装" class="headerlink" title="GLFW安装"></a>GLFW安装</h3><p>头文件添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW\glfw3.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;gcc 在编译时需要加入<code>-lGLEW -lglfw3 -lGL -lX11 -lpthread -lXrandr -lXi</code>，否则可能出现未定义的引用错误</p><p>待完成</p><h2 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h2><p>&emsp;&emsp;因为OpenGL只是个规范，具体是由显卡驱动开发商决定，很多函数位置不能在编译时决定，自己来取得地址的话会导致代码很复杂，所以需要使用GLAD来帮我们实现</p><h3 id="GLAD配置"><a href="#GLAD配置" class="headerlink" title="GLAD配置"></a>GLAD配置</h3><p>&emsp;&emsp;GLAD有一个<a href="https://glad.dav1d.de/" target="_blank" rel="noopener">在线服务</a>可以根据语言、版本、模式来获取我们想要的库。打开后，语言选择C/C++，模式选择core，版本选择3.3(因为我用的是3.3版本)<br>&emsp;&emsp;把生成的压缩文件解压，里面的glad和KHR目录放在你的项目头文件目录，glad.c也添加到工程中，并在项目引入头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h2><p>&emsp;&emsp;由于我使用的CLion创建的项目，所以也就使用CMake了，CMakeLists.txt部分内容如下<br>添加glad库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(glad SHARED ./src/glad/glad.c)</span><br></pre></td></tr></table></figure><p>添加stb_image(加载图片用)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(stb_image SHARED ./src/stb_image/stb_image.cpp)</span><br></pre></td></tr></table></figure><p>链接库(opengl_glfw03是项目可执行文件)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(opengl_glfw03 glad)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(opengl_glfw03 stb_image)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(opengl_glfw03 GLEW)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(opengl_glfw03 glfw3)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(opengl_glfw03 GL)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(opengl_glfw03 X11)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(opengl_glfw03 pthread)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(opengl_glfw03 Xrandr)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(opengl_glfw03 Xi)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(opengl_glfw03 Xxf86vm)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(opengl_glfw03 Xinerama)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(opengl_glfw03 Xcursor)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(opengl_glfw03 rt)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(opengl_glfw03 m)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(opengl_glfw03 dl)</span><br></pre></td></tr></table></figure><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><p>编译没问题的话就可以创建窗口了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="开始创建窗口"><a href="#开始创建窗口" class="headerlink" title="开始创建窗口"></a>开始创建窗口</h1><ul><li>初始化GLFW</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwInit();</span><br></pre></td></tr></table></figure><ul><li>GLFW选项设置函数<br><code>hint</code>：需要设置的选项<br><code>value</code>：需要设置的值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwWindowHint(<span class="keyword">int</span> hint,<span class="keyword">int</span> value);</span><br></pre></td></tr></table></figure><ul><li>配置上下文版本为3.3</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,<span class="number">3</span>);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>配置OpenGL模式为<code>核心(core)</code>模式</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);</span><br></pre></td></tr></table></figure><ul><li>配置多重采样实现抗锯齿</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwWindowHint(GLFW_SAMPLES,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>别忘了启用OpenGL的多重采样，虽然默认是启用的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_MULTISAMPLE);</span><br></pre></td></tr></table></figure><ul><li>创建窗口对象<br><strong>width</strong>：窗口宽度<br><strong>height</strong>：窗口高度<br><strong>title</strong>：窗口标题<br><strong>monitor</strong>：<br><strong>share</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwCreateWindow(<span class="keyword">int</span> width,<span class="keyword">int</span> height,<span class="keyword">const</span> <span class="keyword">char</span> *title,GLFWmonitor *monitor,GLFWwindow *share);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GLFWwindow *window=glfwCreateWindow(<span class="number">1200</span>,<span class="number">720</span>,<span class="string">"OpenGL"</span>,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span>(window==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="comment">// 当窗口创建失败时中断并退出</span></span><br><span class="line">    ...</span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将当前窗口设置为主线程上下文</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwMakeContextCurrent(window);</span><br></pre></td></tr></table></figure><ul><li>初始化GLAD</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123;</span><br><span class="line">    <span class="comment">// 当GLAD初始化失败时退出</span></span><br><span class="line">    ...</span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加窗口大小改变回调</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onFramebufferSizeCallback</span><span class="params">(GLFWwindow*,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 添加回调</span></span><br><span class="line">glfwSetFramebufferSizeCallback(window,onFramebufferSizeCallback);</span><br></pre></td></tr></table></figure><ul><li>在回调中处理视口变换<br><strong>x</strong>：左下角x坐标<br><strong>y</strong>：左下角y坐标<br><strong>width</strong>：渲染宽度<br><strong>height</strong>：渲染高度</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glViewport(GLint x,GLint y,GLsizei width,GLsizei height);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onFramebufferSizeCallback</span><span class="params">(GLFWwindow *window,<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">    glViewport(<span class="number">0</span>,<span class="number">0</span>,width,height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>渲染循环<br>为了避免一运行就退出</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!glfwWindowShouldClose(window))&#123;</span><br><span class="line">    <span class="comment">// 交换颜色缓冲</span></span><br><span class="line">    glfwSwapBuffers(window);</span><br><span class="line">    <span class="comment">// 检查触发事件</span></span><br><span class="line">    glfwPollEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>清除窗口颜色缓冲<br><strong>red</strong>：红<br><strong>green</strong>：绿<br><strong>blue</strong>：蓝<br><strong>alpha</strong>：透明通道</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glClearColor(GLfloat red,GLfloat green,GLfloat blue,GLfloat alpha);</span><br></pre></td></tr></table></figure><p>写在处理键盘事件代码之后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用glClearColor设置的颜色填充</span></span><br><span class="line">glClearColor(<span class="number">0.5f</span>,<span class="number">0.5f</span>,<span class="number">0.6f</span>,<span class="number">1.0f</span>);</span><br><span class="line"><span class="comment">// 清除颜色缓冲</span></span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure><ul><li>处理键盘事件<br>声明函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onKeyInput</span><span class="params">(GLFWwindow *)</span></span>;</span><br></pre></td></tr></table></figure><p>  处理键盘事件写在循环体内部第一行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onKeyInput(window);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onKeyInput</span><span class="params">(GLFWwindow *window)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断ESC按钮就是否触发</span></span><br><span class="line">    <span class="keyword">if</span>(glfwGetKey(window,GLFW_KEY_ESCAPE)==GLFW_PRESS)&#123;</span><br><span class="line">        <span class="comment">// 触发就设置close为真</span></span><br><span class="line">        glfwSetWindowShouldClose(window,GLFW_TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>清理资源并退出</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glfwTerminate();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>此时运行代码应该会出现一个窗口像下面这个，按ESC即可退出，后面会在此基础上添加很多东西<br><strong><a href="https://github.com/xiaohuihuiold/opengl" target="_blank" rel="noopener">代码Github地址</a></strong><br><img src="/2019/02/21/Learn-OpenGL-一-简介与创建窗口/opengl_window.png" alt="opengl_window"></p>]]></content:encoded>
      
      <comments>https://blog.xhhold.com/2019/02/21/Learn-OpenGL-%E4%B8%80-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>排序算法(一)--冒泡排序</title>
      <link>https://blog.xhhold.com/2019/02/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E4%B8%80-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link>
      <guid>https://blog.xhhold.com/2019/02/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E4%B8%80-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid>
      <pubDate>Sat, 16 Feb 2019 05:27:13 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;冒泡排序是一种简单的排序算法&lt;br&gt;&amp;emsp;&amp;emsp;重复的遍历要排序的数组，每次比较两个相邻
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>&emsp;&emsp;冒泡排序是一种简单的排序算法<br>&emsp;&emsp;重复的遍历要排序的数组，每次比较两个相邻的元素，符合给定的条件则交换两个元素，重复的遍历直到没有相邻的元素需要交换</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最好的情况：O(n)</li><li>最坏的情况：O(n<sup>2</sup>)</li><li>平均：O(n<sup>2</sup>)</li></ul><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><ul><li>空间复杂度：O(1)</li></ul><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>冒泡排序是通过遍历比较相邻的两个元素来实现的<br>以下数字排序<br><code>2,3,4,1</code></p><p><strong>第一轮第一次</strong><br>2和3进行比较，因为2不大于3，所以不交换<br><code>2,3,4,1</code></p><p><strong>第一轮第二次</strong><br>3和4进行比较，因为3不大于4，所以不交换<br><code>2,3,4,1</code></p><p><strong>第一轮第三次</strong><br>4和1进行比较，因为4大于1，所以交换<br><code>2,3,1,4</code></p><p><strong>第二轮第一次</strong><br>2和3进行比较，因为2不大于3，所以不交换<br><code>2,3,1,4</code></p><p><strong>第二轮第二次</strong><br>3和1进行比较，因为3大于1，所以交换<br><code>2,1,3,4</code></p><p><strong>第三轮第一次</strong><br>2和1进行比较，因为2大于1，所以交换<br><code>1,2,3,4</code><br>到这里就排序完成了<br>还可以看看下面的动画演示</p><p>假如有以下数字需要排序</p><button id="xhh-btn-sort">点击开始排序</button><button id="xhh-btn-reset">重置</button><p id="xhh-text-log"></p><div class="table-container"><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>元素</td><td>2</td><td>3</td><td>1</td><td>4</td><td>2</td><td>6</td><td>7</td><td>9</td><td>1</td><td>5</td></tr></tbody></table></div><script>    let table=document.getElementsByTagName("table")[0];    let startSort=document.getElementById("xhh-btn-sort");    let reset=document.getElementById("xhh-btn-reset");    let textLog=document.getElementById("xhh-text-log");    let indices=table.getElementsByTagName("th");    let elements=table.getElementsByTagName("td");    let arr=[2,3,1,4,2,6,7,9,1,5];    let timer=new Array();    reset.onclick=function(){       resetSort();    };    startSort.onclick=function(){        resetSort();        let count=0;        for(let i=1;i<elements.length-1;i++){            for(let j=1;j<elements.length-1-i+1;j++){              timer.push(setTimeout(function(){                  clearColor();                  //indices[j].style.background="#87daff";                  //indices[j+1].style.background="#d60036";                  elements[j].style.background="#87daff";                  elements[j+1].style.background="#ffda87";                  if(elements[j].innerHTML>elements[j+1].innerHTML){                      textLog.innerHTML=elements[j].innerHTML+"大于"+elements[j+1].innerHTML+"<br>进行交换";                       let temp=elements[j].innerHTML;                       elements[j].innerHTML=elements[j+1].innerHTML;                       elements[j+1].innerHTML=temp;                  }else{                      textLog.innerHTML=elements[j].innerHTML+"小于等于"+elements[j+1].innerHTML+"<br>不进行操作";                  }              },++count*2000));            }        }    };    function resetSort(){        for(let i=0;i<timer.length;i++){            clearTimeout(timer[i]);        }        for(let i=1;i<elements.length;i++){            elements[i].innerHTML=arr[i-1];        }        clearColor();        timer=new Array();    }    function clearColor(){        for(let k=1;k<indices.length;k++){           indices[k].style.background="";           elements[k].style.background="";        }    }</script><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li>c/c++：<a href="https://github.com/xiaohuihuiold/datastructure_and_algorithm/blob/master/algorithm/bubble_sort/bubble.c" target="_blank" rel="noopener">完整代码</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">      <span class="comment">// 如果j的值大于j下一个的值就交换</span></span><br><span class="line">      <span class="keyword">int</span> temp=arr[j];</span><br><span class="line">      arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">      arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>java：<a href="https://github.com/xiaohuihuiold/datastructure_and_algorithm/blob/master/algorithm/bubble_sort/Bubble.java" target="_blank" rel="noopener">完整代码</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">      <span class="comment">// 如果j的值大于j下一个的值就交换</span></span><br><span class="line">      <span class="keyword">int</span> temp=arr[j];</span><br><span class="line">      arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">      arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>javascript：<a href="https://github.com/xiaohuihuiold/datastructure_and_algorithm/blob/master/algorithm/bubble_sort/bubble.js" target="_blank" rel="noopener">完整代码(nodejs)</a></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;arr.length<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">          <span class="comment">// 如果j的值大于j下一个的值就交换</span></span><br><span class="line">          <span class="keyword">var</span> temp=arr[j];</span><br><span class="line">          arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">          arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>python 3：<a href="https://github.com/xiaohuihuiold/datastructure_and_algorithm/blob/master/algorithm/bubble_sort/bubble.py" target="_blank" rel="noopener">完整代码</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>-i):</span><br><span class="line">      <span class="keyword">if</span> arr[j]&gt;arr[j+<span class="number">1</span>]:</span><br><span class="line">          <span class="comment"># 如果j的值大于j下一个的值就交换</span></span><br><span class="line">          temp=arr[j]</span><br><span class="line">          arr[j]=arr[j+<span class="number">1</span>]</span><br><span class="line">          arr[j+<span class="number">1</span>]=temp</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://blog.xhhold.com/2019/02/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E4%B8%80-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Redis学习(三)--数据类型</title>
      <link>https://blog.xhhold.com/2019/02/15/Redis%E5%AD%A6%E4%B9%A0-%E4%B8%89-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <guid>https://blog.xhhold.com/2019/02/15/Redis%E5%AD%A6%E4%B9%A0-%E4%B8%89-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <pubDate>Thu, 14 Feb 2019 16:51:06 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Redis-数据类型&quot;&gt;&lt;a href=&quot;#Redis-数据类型&quot; class=&quot;headerlink&quot; title=&quot;Redis 数据类型&quot;&gt;&lt;/a&gt;Redis 数据类型&lt;/h1&gt;&lt;p&gt;Redis支持五种数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;字符串：Stri
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h1><p>Redis支持五种数据类型</p><ul><li><p>字符串：String</p></li><li><p>哈希：Hash</p></li><li><p>列表：List</p></li><li><p>集合：Set</p></li><li><p>有序集合：Sorted Set</p></li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>简介</th><th>特性</th></tr></thead><tbody><tr><td>String</td><td>字符串</td><td>二进制安全<br>可以包含任何数据<br>一个键最大储存512M</td></tr><tr><td>Hash</td><td>字典键值对集合</td><td>一个属性对应一个值，适合储存对象</td></tr><tr><td>List</td><td>双向链表</td><td>增删快</td></tr><tr><td>Set</td><td>无序集合</td><td>元素不重复<br>增、删、查的复杂度为O(1)</td></tr><tr><td>Sorted Set</td><td>有序集合</td><td>元素不重复<br>元素按score排序</td></tr></tbody></table></div>]]></content:encoded>
      
      <comments>https://blog.xhhold.com/2019/02/15/Redis%E5%AD%A6%E4%B9%A0-%E4%B8%89-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Redis学习(二)--配置</title>
      <link>https://blog.xhhold.com/2019/02/15/Redis%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%E9%85%8D%E7%BD%AE/</link>
      <guid>https://blog.xhhold.com/2019/02/15/Redis%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Thu, 14 Feb 2019 16:03:26 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Redis-配置&quot;&gt;&lt;a href=&quot;#Redis-配置&quot; class=&quot;headerlink&quot; title=&quot;Redis 配置&quot;&gt;&lt;/a&gt;Redis 配置&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;配置文件：&lt;code&gt;redis.conf&lt;/code&gt;&lt;br&gt;&lt;img src
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Redis-配置"><a href="#Redis-配置" class="headerlink" title="Redis 配置"></a>Redis 配置</h1><ul><li>配置文件：<code>redis.conf</code><br><img src="/2019/02/15/Redis学习-二-配置/redis.conf.png" alt="redis.conf"></li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul><li><strong>获取配置</strong><br>CONFIG GET <code>配置项名</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG GET port</span><br><span class="line">1) <span class="string">"port"</span></span><br><span class="line">2) <span class="string">"6379"</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置配置</strong><br>CONFIG SET <code>配置项名</code> <code>新的值</code><br>如果出现<code>(error) ERR Unsupported CONFIG parameter</code>就说明这个选项不能动态设置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG SET loglevel <span class="string">"notice"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h2 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h2><p>  待更新…</p>]]></content:encoded>
      
      <comments>https://blog.xhhold.com/2019/02/15/Redis%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Redis学习(一)--简介和安装</title>
      <link>https://blog.xhhold.com/2019/02/14/Redis%E5%AD%A6%E4%B9%A0-%E4%B8%80-%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85/</link>
      <guid>https://blog.xhhold.com/2019/02/14/Redis%E5%AD%A6%E4%B9%A0-%E4%B8%80-%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85/</guid>
      <pubDate>Thu, 14 Feb 2019 07:24:39 GMT</pubDate>
      <description>
      
        
        
          &lt;div align=&quot;center&quot;&gt; ![redis logo](redis.jpeg) &lt;/div&gt;

&lt;h1 id=&quot;Redis-简介&quot;&gt;&lt;a href=&quot;#Redis-简介&quot; class=&quot;headerlink&quot; title=&quot;Redis 简介&quot;&gt;&lt;/a&gt;Redis 简
        
      
      </description>
      
      <content:encoded><![CDATA[<div align="center"> ![redis logo](redis.jpeg) </div><h1 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h1><p>Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存也可以持久化的日志型、Key-Value数据库</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>支持数据持久化</li><li>支持<code>key-value</code>、<code>list</code>、<code>set</code>、<code>zset</code>、<code>hash</code>等数据结构</li><li>支持<code>master-slave</code>模式的数据备份</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>性能极高</li><li>数据类型丰富</li><li>操作都是原子性的(要么成功执行，要么失败完全不执行)</li><li>特性丰富</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>注：本机系统<code>ArchLinux</code></p><ul><li><p><strong>Linux</strong></p><ul><li><p><strong>ArchLinux</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S redis</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yay -S redis</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p><strong>Ubuntu</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install redis-server</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Windows10</strong></p><p>Windows暂时不讨论</p></li><li><p><strong>Mac</strong></p><p>Mac暂时不讨论</p></li></ul><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><ul><li><strong>启动Redis</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><strong>查看是否启动</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>或者<br>redis-cli -h <code>主机ip</code> -p <code>redis端口</code> -a <code>密码</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 6379</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当启动成功后会进入redis的终端<br><code>127.0.0.1</code>：本机IP<br><code>6379</code>：redis服务端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>输入<code>ping</code>命令<br>服务器运行正常会返回<code>PONG</code><br>否则返回连接错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><p>说明已经成功安装</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>安装(本机终端): <code>yay -S redis</code></li><li>启动(终端): <code>redis-server</code></li><li>连接(终端): <code>redis-cli</code></li><li>检查(redis-cli): <code>ping</code></li></ul>]]></content:encoded>
      
      <comments>https://blog.xhhold.com/2019/02/14/Redis%E5%AD%A6%E4%B9%A0-%E4%B8%80-%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
